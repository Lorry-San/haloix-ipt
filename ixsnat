#!/bin/bash
###########################################
# SNAT + 策略路由 一体化配置脚本
# 改进版：增强 SSH 连接诊断
###########################################

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 全局变量
INTERNAL_IF="ens20"
EXTERNAL_IF="ens18"
ALLOWED_IPS=()
LOCAL_ENS20_IP=""

###########################################
# 工具函数
###########################################

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_debug() {
    echo -e "${BLUE}[DEBUG]${NC} $1"
}

log_step() {
    echo -e "${PURPLE}[STEP]${NC} $1"
}

print_header() {
    echo ""
    echo -e "${CYAN}=============================================================${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}=============================================================${NC}"
    echo ""
}

check_root() {
    if [ "$EUID" -ne 0 ]; then 
        log_error "请使用 root 权限运行此脚本"
        exit 1
    fi
}

check_interface() {
    if ! ip link show "$1" &> /dev/null; then
        log_error "网卡 $1 不存在"
        exit 1
    fi
    log_debug "网卡 $1 检查通过"
}

get_internal_network() {
    local network=$(ip -o -f inet addr show "$INTERNAL_IF" | awk '{print $4}')
    if [ -z "$network" ]; then
        log_error "无法从 $INTERNAL_IF 获取IP段"
        exit 1
    fi
    echo "$network"
}

get_internal_ip() {
    local ip=$(ip -o -f inet addr show "$INTERNAL_IF" | awk '{print $4}' | cut -d'/' -f1)
    if [ -z "$ip" ]; then
        log_error "无法从 $INTERNAL_IF 获取IP地址"
        exit 1
    fi
    echo "$ip"
}

get_external_ip() {
    local ip=$(ip -o -f inet addr show "$EXTERNAL_IF" | awk '{print $4}' | cut -d'/' -f1)
    if [ -z "$ip" ]; then
        log_error "无法从 $EXTERNAL_IF 获取公网IP"
        exit 1
    fi
    echo "$ip"
}

validate_ip() {
    local ip=$1
    if [[ "$ip" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}(/[0-9]{1,2})?$ ]]; then
        return 0
    else
        return 1
    fi
}

save_iptables() {
    log_debug "保存 iptables 规则..."
    if command -v iptables-save &> /dev/null; then
        mkdir -p /etc/iptables
        iptables-save > /etc/iptables/rules.v4
        log_debug "规则已保存"
    else
        log_warn "未找到 iptables-save 命令，规则未持久化"
    fi
}

###########################################
# SSH 连接测试增强函数
###########################################

test_ssh_connection() {
    local remote_ip="$1"
    local remote_password="$2"
    local ssh_port="${3:-22}"
    local ssh_user="${4:-root}"
    
    print_header "SSH 连接诊断"
    
    # 1. 检查 sshpass 工具
    echo -e "${BLUE}[检查 1/6]${NC} 检查必要工具..."
    if ! command -v sshpass &> /dev/null; then
        log_error "未安装 sshpass 工具"
        echo ""
        echo -e "${YELLOW}请先安装 sshpass：${NC}"
        echo "  Debian/Ubuntu: apt install sshpass"
        echo "  CentOS/RHEL:   yum install sshpass"
        echo "  macOS:         brew install hudochenkov/sshpass/sshpass"
        return 1
    fi
    log_info "✓ sshpass 已安装"
    
    if ! command -v nc &> /dev/null && ! command -v telnet &> /dev/null; then
        log_warn "建议安装 nc 或 telnet 以进行端口测试"
    fi
    
    # 2. 检查 IP 地址可达性
    echo ""
    echo -e "${BLUE}[检查 2/6]${NC} 测试 IP 可达性..."
    if ping -c 2 -W 2 "$remote_ip" &>/dev/null; then
        log_info "✓ IP 地址 $remote_ip 可达 (ICMP)"
    else
        log_warn "⚠ IP 地址 $remote_ip ICMP 不通（可能防火墙阻止 ping）"
        echo "    继续测试 SSH 端口..."
    fi
    
    # 3. 检查 SSH 端口是否开放
    echo ""
    echo -e "${BLUE}[检查 3/6]${NC} 测试 SSH 端口 ($ssh_port) 可达性..."
    local port_status=""
    
    if command -v nc &> /dev/null; then
        if timeout 3 nc -zv "$remote_ip" "$ssh_port" 2>&1 | grep -q "succeeded\|open"; then
            port_status="open"
        else
            port_status="closed"
        fi
    elif command -v telnet &> /dev/null; then
        if timeout 3 bash -c "echo '' | telnet $remote_ip $ssh_port 2>&1" | grep -q "Connected\|Escape"; then
            port_status="open"
        else
            port_status="closed"
        fi
    else
        # 使用 timeout + bash 的 /dev/tcp 测试
        if timeout 3 bash -c "cat < /dev/null > /dev/tcp/$remote_ip/$ssh_port" 2>/dev/null; then
            port_status="open"
        else
            port_status="closed"
        fi
    fi
    
    if [ "$port_status" = "open" ]; then
        log_info "✓ SSH 端口 $ssh_port 已开放"
    elif [ "$port_status" = "closed" ]; then
        log_error "✗ SSH 端口 $ssh_port 无法访问"
        echo ""
        echo -e "${YELLOW}可能的原因：${NC}"
        echo "  1. SSH 服务未启动"
        echo "  2. 防火墙阻止了端口 $ssh_port"
        echo "  3. SSH 监听在不同的端口"
        echo "  4. 网络路由问题"
        echo ""
        echo -e "${YELLOW}建议检查：${NC}"
        echo "  在远程服务器上运行："
        echo "    systemctl status sshd"
        echo "    ss -tlnp | grep :$ssh_port"
        echo "    iptables -L -n | grep $ssh_port"
        return 1
    else
        log_warn "⚠ 无法确定端口状态，继续尝试..."
    fi
    
    # 4. 测试 SSH 协议握手
    echo ""
    echo -e "${BLUE}[检查 4/6]${NC} 测试 SSH 协议握手..."
    local ssh_banner=$(timeout 5 ssh -o BatchMode=yes -o ConnectTimeout=3 -p "$ssh_port" "${ssh_user}@${remote_ip}" 2>&1)
    
    if echo "$ssh_banner" | grep -qi "Permission denied"; then
        log_info "✓ SSH 服务正常响应（需要认证）"
    elif echo "$ssh_banner" | grep -qi "Connection refused"; then
        log_error "✗ SSH 连接被拒绝"
        echo ""
        echo -e "${YELLOW}可能的原因：${NC}"
        echo "  1. SSH 服务未运行"
        echo "  2. 端口配置错误"
        return 1
    elif echo "$ssh_banner" | grep -qi "Connection timed out\|No route to host"; then
        log_error "✗ 连接超时或无路由"
        echo ""
        echo -e "${YELLOW}可能的原因：${NC}"
        echo "  1. IP 地址不可达"
        echo "  2. 防火墙阻止"
        echo "  3. 网络配置问题"
        return 1
    elif echo "$ssh_banner" | grep -qi "Host key verification failed"; then
        log_info "✓ SSH 服务正常响应（主机密钥问题）"
    else
        log_debug "SSH 协议响应: $(echo "$ssh_banner" | head -1)"
    fi
    
    # 5. 测试无密码连接（检查是否有密钥认证）
    echo ""
    echo -e "${BLUE}[检查 5/6]${NC} 测试密钥认证..."
    if ssh -o BatchMode=yes -o ConnectTimeout=3 -o StrictHostKeyChecking=no \
           -p "$ssh_port" "${ssh_user}@${remote_ip}" "echo 'SSH 连接成功'" 2>/dev/null; then
        log_info "✓ 密钥认证成功（无需密码）"
        return 0
    else
        log_info "○ 密钥认证不可用，需要密码认证"
    fi
    
    # 6. 测试密码认证
    echo ""
    echo -e "${BLUE}[检查 6/6]${NC} 测试密码认证..."
    
    # 创建临时文件记录详细错误
    local temp_log=$(mktemp)
    
    # 尝试连接并捕获详细输出
    sshpass -p "$remote_password" ssh \
        -o ConnectTimeout=5 \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        -p "$ssh_port" \
        "${ssh_user}@${remote_ip}" \
        "echo 'SSH 连接成功'" > "$temp_log" 2>&1
    
    local ssh_result=$?
    local ssh_output=$(cat "$temp_log")
    rm -f "$temp_log"
    
    # 分析返回码和输出
    if [ $ssh_result -eq 0 ]; then
        log_info "✅ 密码认证成功！"
        echo ""
        return 0
    else
        log_error "✗ 密码认证失败"
        echo ""
        
        # 详细错误分析
        echo -e "${YELLOW}错误分析：${NC}"
        
        if echo "$ssh_output" | grep -qi "Permission denied"; then
            echo -e "${RED}► 密码错误${NC}"
            echo ""
            echo "可能的原因："
            echo "  1. 输入的密码不正确"
            echo "  2. 用户 '$ssh_user' 不存在"
            echo "  3. 用户 '$ssh_user' 被禁用"
            echo "  4. SSH 配置禁止密码登录 (PasswordAuthentication no)"
            echo ""
            echo "建议操作："
            echo "  1. 确认密码是否正确"
            echo "  2. 检查远程服务器 /etc/ssh/sshd_config："
            echo "     PasswordAuthentication yes"
            echo "     PermitRootLogin yes  (如果用户是 root)"
            
        elif echo "$ssh_output" | grep -qi "Connection refused"; then
            echo -e "${RED}► 连接被拒绝${NC}"
            echo ""
            echo "可能的原因："
            echo "  1. SSH 服务未运行"
            echo "  2. 端口 $ssh_port 不正确"
            echo ""
            echo "建议操作："
            echo "  在远程服务器运行："
            echo "    systemctl start sshd"
            echo "    systemctl enable sshd"
            
        elif echo "$ssh_output" | grep -qi "Connection timed out"; then
            echo -e "${RED}► 连接超时${NC}"
            echo ""
            echo "可能的原因："
            echo "  1. 防火墙阻止了 SSH 连接"
            echo "  2. 网络不通"
            echo "  3. IP 地址错误"
            echo ""
            echo "建议操作："
            echo "  1. 检查防火墙规则"
            echo "  2. ping $remote_ip"
            echo "  3. 确认 IP 地址正确"
            
        elif echo "$ssh_output" | grep -qi "Network is unreachable\|No route to host"; then
            echo -e "${RED}► 网络不可达${NC}"
            echo ""
            echo "可能的原因："
            echo "  1. IP 地址不在同一网段"
            echo "  2. 路由配置问题"
            echo "  3. 网关配置错误"
            echo ""
            echo "建议操作："
            echo "  1. 检查 IP 地址和网段"
            echo "  2. ip route get $remote_ip"
            echo "  3. 检查网关配置"
            
        elif echo "$ssh_output" | grep -qi "Too many authentication failures"; then
            echo -e "${RED}► 认证尝试次数过多${NC}"
            echo ""
            echo "可能的原因："
            echo "  1. 多次密码错误导致暂时锁定"
            echo "  2. SSH 配置限制了尝试次数"
            echo ""
            echo "建议操作："
            echo "  1. 等待几分钟后重试"
            echo "  2. 检查 /etc/ssh/sshd_config 的 MaxAuthTries"
            
        elif echo "$ssh_output" | grep -qi "Host key verification failed"; then
            echo -e "${RED}► 主机密钥验证失败${NC}"
            echo ""
            echo "可能的原因："
            echo "  1. 远程主机密钥已更改"
            echo "  2. 可能存在中间人攻击"
            echo ""
            echo "建议操作："
            echo "  1. 删除旧的主机密钥："
            echo "     ssh-keygen -R $remote_ip"
            echo "  2. 或编辑 ~/.ssh/known_hosts"
            
        elif echo "$ssh_output" | grep -qi "Could not resolve hostname"; then
            echo -e "${RED}► 无法解析主机名${NC}"
            echo ""
            echo "可能的原因："
            echo "  1. DNS 解析失败"
            echo "  2. 主机名错误"
            echo ""
            echo "建议操作："
            echo "  1. 使用 IP 地址而非主机名"
            echo "  2. 检查 DNS 配置"
            
        else
            echo -e "${RED}► 未知错误${NC}"
            echo ""
            echo "详细错误信息："
            echo "$ssh_output" | head -5
            echo ""
            echo "返回码: $ssh_result"
        fi
        
        echo ""
        echo -e "${CYAN}===============================================================${NC}"
        echo -e "${CYAN}  诊断摘要${NC}"
        echo -e "${CYAN}===============================================================${NC}"
        echo "目标地址: ${ssh_user}@${remote_ip}:${ssh_port}"
        echo "认证方式: 密码认证"
        echo "连接状态: 失败"
        echo ""
        
        return 1
    fi
}

# 重试机制
retry_ssh_connection() {
    local remote_ip="$1"
    local ssh_port="${2:-22}"
    local ssh_user="${3:-root}"
    local max_retries=3
    local retry_count=0
    
    while [ $retry_count -lt $max_retries ]; do
        echo ""
        if [ $retry_count -gt 0 ]; then
            echo -e "${YELLOW}第 $((retry_count + 1)) 次尝试 (共 $max_retries 次)${NC}"
        fi
        
        read -s -p "请输入 SSH 密码: " remote_password
        echo ""
        
        if [ -z "$remote_password" ]; then
            log_error "密码不能为空！"
            retry_count=$((retry_count + 1))
            continue
        fi
        
        if test_ssh_connection "$remote_ip" "$remote_password" "$ssh_port" "$ssh_user"; then
            echo "$remote_password"
            return 0
        fi
        
        retry_count=$((retry_count + 1))
        
        if [ $retry_count -lt $max_retries ]; then
            echo ""
            read -p "是否重试？(y/n) [y]: " retry
            retry=${retry:-y}
            if [[ ! "$retry" =~ ^[Yy]$ ]]; then
                return 1
            fi
        fi
    done
    
    echo ""
    log_error "已达到最大重试次数 ($max_retries)"
    return 1
}

###########################################
# SNAT 配置函数（保持原样）
###########################################

init_snat() {
    log_step "初始化 SNAT 配置..."
    
    check_interface "$INTERNAL_IF"
    check_interface "$EXTERNAL_IF"
    
    INTERNAL_NETWORK=$(get_internal_network)
    EXTERNAL_IP=$(get_external_ip)
    LOCAL_ENS20_IP=$(get_internal_ip)
    
    log_info "内网网段: $INTERNAL_NETWORK"
    log_info "内网IP (ens20): $LOCAL_ENS20_IP"
    log_info "外网IP (ens18): $EXTERNAL_IP"
    
    echo 1 > /proc/sys/net/ipv4/ip_forward
    
    if ! grep -q "^net.ipv4.ip_forward=1" /etc/sysctl.conf; then
        echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf
        sysctl -p > /dev/null 2>&1
    fi
    
    iptables -t nat -D POSTROUTING -s "$INTERNAL_NETWORK" -o "$EXTERNAL_IF" -j SNAT --to-source "$EXTERNAL_IP" 2>/dev/null
    iptables -P FORWARD DROP
    iptables -D FORWARD -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j LOG 2>/dev/null
    iptables -D FORWARD -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j REJECT 2>/dev/null
    
    if ! iptables -C FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT 2>/dev/null; then
        iptables -I FORWARD 1 -m state --state ESTABLISHED,RELATED -j ACCEPT
    fi
    
    for ip in "${ALLOWED_IPS[@]}"; do
        add_allowed_ip "$ip" "silent"
    done
    
    if ! iptables -C FORWARD -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j LOG --log-prefix "FORWARD_REJECT: " 2>/dev/null; then
        iptables -A FORWARD -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j LOG --log-prefix "FORWARD_REJECT: " --log-level 4
    fi
    if ! iptables -C FORWARD -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j REJECT 2>/dev/null; then
        iptables -A FORWARD -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j REJECT --reject-with icmp-host-prohibited
    fi
    
    iptables -t nat -A POSTROUTING -s "$INTERNAL_NETWORK" -o "$EXTERNAL_IF" -j SNAT --to-source "$EXTERNAL_IP"
    
    save_iptables
    
    log_info "✅ SNAT 配置完成"
}

add_allowed_ip() {
    local ip="$1"
    local mode="$2"
    
    if [ -z "$ip" ]; then
        log_error "请指定IP地址"
        return 1
    fi
    
    if ! validate_ip "$ip"; then
        log_error "无效的IP地址格式: $ip"
        return 1
    fi
    
    if iptables -C FORWARD -s "$ip" -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j ACCEPT 2>/dev/null; then
        if [ "$mode" != "silent" ]; then
            log_warn "IP $ip 已在允许列表中"
        fi
        return 0
    fi
    
    iptables -I FORWARD 2 -s "$ip" -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j ACCEPT
    
    if [ $? -eq 0 ]; then
        if [ "$mode" != "silent" ]; then
            log_info "✅ 已添加 $ip 到允许转发列表"
        fi
        return 0
    else
        log_error "添加 $ip 失败"
        return 1
    fi
}

show_snat_summary() {
    print_header "SNAT 配置摘要"
    
    INTERNAL_NETWORK=$(get_internal_network)
    EXTERNAL_IP=$(get_external_ip)
    LOCAL_ENS20_IP=$(get_internal_ip)
    
    echo -e "${CYAN}内网接口:${NC} $INTERNAL_IF"
    echo -e "  • IP: $LOCAL_ENS20_IP"
    echo -e "  • 网段: $INTERNAL_NETWORK"
    echo -e "${CYAN}外网接口:${NC} $EXTERNAL_IF ($EXTERNAL_IP)"
    echo -e "${CYAN}允许转发的IP:${NC}"
    
    for ip in "${ALLOWED_IPS[@]}"; do
        echo "  • $ip"
    done
    
    echo ""
}

###########################################
# 远程配置函数（使用改进的 SSH 测试）
###########################################

configure_remote_policy_routing() {
    print_header "远程策略路由配置"
    
    local remote_ip="$1"
    local remote_password="$2"
    local gateway_ip="$3"
    
    log_info "目标服务器: $remote_ip"
    log_info "ens20 网关将设置为: $gateway_ip (本机 ens20)"
    
    local ssh_port=22
    local ssh_user="root"
    
    # 使用改进的 SSH 测试
    if ! test_ssh_connection "$remote_ip" "$remote_password" "$ssh_port" "$ssh_user"; then
        return 1
    fi
    
    # 创建临时脚本文件（远程执行脚本保持原样，这里省略）
    local temp_script="/tmp/remote_policy_routing_$$.sh"
    
    # ... 原有的脚本生成代码 ...
    
    log_step "执行远程策略路由配置..."
    echo ""
    
    if sshpass -p "$remote_password" ssh -o StrictHostKeyChecking=no -p $ssh_port ${ssh_user}@${remote_ip} "bash -s" < "$temp_script" 2>&1; then
        echo ""
        log_info "✅ 远程策略路由配置成功！"
        rm -f "$temp_script"
        return 0
    else
        echo ""
        log_error "远程配置失败！"
        rm -f "$temp_script"
        return 1
    fi
}

###########################################
# 交互式配置主流程（使用重试机制）
###########################################

interactive_setup() {
    check_root
    
    print_header "Halocloud IX SNAT + 策略路由配置脚本 v2.1"
    
    check_interface "$INTERNAL_IF"
    LOCAL_ENS20_IP=$(get_internal_ip)
    
    log_info "本机 ens20 IP: $LOCAL_ENS20_IP"
    log_info "此 IP 将作为 IX 端 ens20 的网关"
    
    echo ""
    log_step "步骤 1/3: 配置远程 IX 服务器"
    echo ""
    
    read -p "请输入 IX 服务器的 IP 地址: " IX_SERVER_IP
    if [ -z "$IX_SERVER_IP" ]; then
        log_error "IP 地址不能为空！"
        exit 1
    fi
    
    if ! validate_ip "$IX_SERVER_IP"; then
        log_error "无效的 IP 地址格式！"
        exit 1
    fi
    
    # 使用重试机制获取密码
    IX_SERVER_PASSWORD=$(retry_ssh_connection "$IX_SERVER_IP")
    if [ $? -ne 0 ] || [ -z "$IX_SERVER_PASSWORD" ]; then
        log_error "无法建立 SSH 连接"
        exit 1
    fi
    
    ALLOWED_IPS+=("$IX_SERVER_IP")
    log_info "✅ IX IP $IX_SERVER_IP 已自动添加到允许列表"
    
    # 其余代码保持原样...
}

###########################################
# 主函数
###########################################

main() {
    case "${1:-setup}" in
        setup|init|config|configure)
            interactive_setup
            ;;
        test-ssh)
            # 新增：测试 SSH 连接命令
            if [ -z "$2" ]; then
                echo "用法: $0 test-ssh <IP地址> [端口] [用户名]"
                exit 1
            fi
            read -s -p "请输入 SSH 密码: " password
            echo ""
            test_ssh_connection "$2" "$password" "${3:-22}" "${4:-root}"
            ;;
        *)
            interactive_setup
            ;;
    esac
}

main "$@"
