#!/bin/bash
###########################################
# SNAT + ç­–ç•¥è·¯ç”± ä¸€ä½“åŒ–é…ç½®è„šæœ¬
# æ”¹è¿›ç‰ˆï¼šå¢å¼º SSH è¿æ¥è¯Šæ–­ + DNS é…ç½®
###########################################

# é¢œè‰²å®šä¹‰
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# å…¨å±€å˜é‡
INTERNAL_IF="ens20"
EXTERNAL_IF="ens18"
ALLOWED_IPS=()
LOCAL_ENS20_IP=""

###########################################
# å·¥å…·å‡½æ•°
###########################################

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_debug() {
    echo -e "${BLUE}[DEBUG]${NC} $1"
}

log_step() {
    echo -e "${PURPLE}[STEP]${NC} $1"
}

print_header() {
    echo ""
    echo -e "${CYAN}=============================================================${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}=============================================================${NC}"
    echo ""
}

check_root() {
    if [ "$EUID" -ne 0 ]; then 
        log_error "è¯·ä½¿ç”¨ root æƒé™è¿è¡Œæ­¤è„šæœ¬"
        exit 1
    fi
}

check_interface() {
    if ! ip link show "$1" &> /dev/null; then
        log_error "ç½‘å¡ $1 ä¸å­˜åœ¨"
        exit 1
    fi
    log_debug "ç½‘å¡ $1 æ£€æŸ¥é€šè¿‡"
}

get_internal_network() {
    local network=$(ip -o -f inet addr show "$INTERNAL_IF" | awk '{print $4}')
    if [ -z "$network" ]; then
        log_error "æ— æ³•ä» $INTERNAL_IF è·å–IPæ®µ"
        exit 1
    fi
    echo "$network"
}

get_internal_ip() {
    local ip=$(ip -o -f inet addr show "$INTERNAL_IF" | awk '{print $4}' | cut -d'/' -f1)
    if [ -z "$ip" ]; then
        log_error "æ— æ³•ä» $INTERNAL_IF è·å–IPåœ°å€"
        exit 1
    fi
    echo "$ip"
}

get_external_ip() {
    local ip=$(ip -o -f inet addr show "$EXTERNAL_IF" | awk '{print $4}' | cut -d'/' -f1)
    if [ -z "$ip" ]; then
        log_error "æ— æ³•ä» $EXTERNAL_IF è·å–å…¬ç½‘IP"
        exit 1
    fi
    echo "$ip"
}

validate_ip() {
    local ip=$1
    if [[ "$ip" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}(/[0-9]{1,2})?$ ]]; then
        return 0
    else
        return 1
    fi
}

save_iptables() {
    log_debug "ä¿å­˜ iptables è§„åˆ™..."
    if command -v iptables-save &> /dev/null; then
        mkdir -p /etc/iptables
        iptables-save > /etc/iptables/rules.v4
        log_debug "è§„åˆ™å·²ä¿å­˜"
    else
        log_warn "æœªæ‰¾åˆ° iptables-save å‘½ä»¤ï¼Œè§„åˆ™æœªæŒä¹…åŒ–"
    fi
}

###########################################
# SSH è¿æ¥æµ‹è¯•å¢å¼ºå‡½æ•°
###########################################

test_ssh_connection() {
    local remote_ip="$1"
    local remote_password="$2"
    local ssh_port="${3:-22}"
    local ssh_user="${4:-root}"
    
    print_header "SSH è¿æ¥è¯Šæ–­"
    
    # 1. æ£€æŸ¥ sshpass å·¥å…·
    echo -e "${BLUE}[æ£€æŸ¥ 1/6]${NC} æ£€æŸ¥å¿…è¦å·¥å…·..."
    if ! command -v sshpass &> /dev/null; then
        log_error "æœªå®‰è£… sshpass å·¥å…·"
        echo ""
        echo -e "${YELLOW}è¯·å…ˆå®‰è£… sshpassï¼š${NC}"
        echo "  Debian/Ubuntu: apt install sshpass"
        echo "  CentOS/RHEL:   yum install sshpass"
        echo "  macOS:         brew install hudochenkov/sshpass/sshpass"
        return 1
    fi
    log_info "âœ“ sshpass å·²å®‰è£…"
    
    if ! command -v nc &> /dev/null && ! command -v telnet &> /dev/null; then
        log_warn "å»ºè®®å®‰è£… nc æˆ– telnet ä»¥è¿›è¡Œç«¯å£æµ‹è¯•"
    fi
    
    # 2. æ£€æŸ¥ IP åœ°å€å¯è¾¾æ€§
    echo ""
    echo -e "${BLUE}[æ£€æŸ¥ 2/6]${NC} æµ‹è¯• IP å¯è¾¾æ€§..."
    if ping -c 2 -W 2 "$remote_ip" &>/dev/null; then
        log_info "âœ“ IP åœ°å€ $remote_ip å¯è¾¾ (ICMP)"
    else
        log_warn "âš  IP åœ°å€ $remote_ip ICMP ä¸é€šï¼ˆå¯èƒ½é˜²ç«å¢™é˜»æ­¢ pingï¼‰"
        echo "    ç»§ç»­æµ‹è¯• SSH ç«¯å£..."
    fi
    
    # 3. æ£€æŸ¥ SSH ç«¯å£æ˜¯å¦å¼€æ”¾
    echo ""
    echo -e "${BLUE}[æ£€æŸ¥ 3/6]${NC} æµ‹è¯• SSH ç«¯å£ ($ssh_port) å¯è¾¾æ€§..."
    local port_status=""
    
    if command -v nc &> /dev/null; then
        if timeout 3 nc -zv "$remote_ip" "$ssh_port" 2>&1 | grep -q "succeeded\|open"; then
            port_status="open"
        else
            port_status="closed"
        fi
    elif command -v telnet &> /dev/null; then
        if timeout 3 bash -c "echo '' | telnet $remote_ip $ssh_port 2>&1" | grep -q "Connected\|Escape"; then
            port_status="open"
        else
            port_status="closed"
        fi
    else
        # ä½¿ç”¨ timeout + bash çš„ /dev/tcp æµ‹è¯•
        if timeout 3 bash -c "cat < /dev/null > /dev/tcp/$remote_ip/$ssh_port" 2>/dev/null; then
            port_status="open"
        else
            port_status="closed"
        fi
    fi
    
    if [ "$port_status" = "open" ]; then
        log_info "âœ“ SSH ç«¯å£ $ssh_port å·²å¼€æ”¾"
    elif [ "$port_status" = "closed" ]; then
        log_error "âœ— SSH ç«¯å£ $ssh_port æ— æ³•è®¿é—®"
        echo ""
        echo -e "${YELLOW}å¯èƒ½çš„åŸå› ï¼š${NC}"
        echo "  1. SSH æœåŠ¡æœªå¯åŠ¨"
        echo "  2. é˜²ç«å¢™é˜»æ­¢äº†ç«¯å£ $ssh_port"
        echo "  3. SSH ç›‘å¬åœ¨ä¸åŒçš„ç«¯å£"
        echo "  4. ç½‘ç»œè·¯ç”±é—®é¢˜"
        echo ""
        echo -e "${YELLOW}å»ºè®®æ£€æŸ¥ï¼š${NC}"
        echo "  åœ¨è¿œç¨‹æœåŠ¡å™¨ä¸Šè¿è¡Œï¼š"
        echo "    systemctl status sshd"
        echo "    ss -tlnp | grep :$ssh_port"
        echo "    iptables -L -n | grep $ssh_port"
        return 1
    else
        log_warn "âš  æ— æ³•ç¡®å®šç«¯å£çŠ¶æ€ï¼Œç»§ç»­å°è¯•..."
    fi
    
    # 4. æµ‹è¯• SSH åè®®æ¡æ‰‹
    echo ""
    echo -e "${BLUE}[æ£€æŸ¥ 4/6]${NC} æµ‹è¯• SSH åè®®æ¡æ‰‹..."
    local ssh_banner=$(timeout 5 ssh -o BatchMode=yes -o ConnectTimeout=3 -p "$ssh_port" "${ssh_user}@${remote_ip}" 2>&1)
    
    if echo "$ssh_banner" | grep -qi "Permission denied"; then
        log_info "âœ“ SSH æœåŠ¡æ­£å¸¸å“åº”ï¼ˆéœ€è¦è®¤è¯ï¼‰"
    elif echo "$ssh_banner" | grep -qi "Connection refused"; then
        log_error "âœ— SSH è¿æ¥è¢«æ‹’ç»"
        echo ""
        echo -e "${YELLOW}å¯èƒ½çš„åŸå› ï¼š${NC}"
        echo "  1. SSH æœåŠ¡æœªè¿è¡Œ"
        echo "  2. ç«¯å£é…ç½®é”™è¯¯"
        return 1
    elif echo "$ssh_banner" | grep -qi "Connection timed out\|No route to host"; then
        log_error "âœ— è¿æ¥è¶…æ—¶æˆ–æ— è·¯ç”±"
        echo ""
        echo -e "${YELLOW}å¯èƒ½çš„åŸå› ï¼š${NC}"
        echo "  1. IP åœ°å€ä¸å¯è¾¾"
        echo "  2. é˜²ç«å¢™é˜»æ­¢"
        echo "  3. ç½‘ç»œé…ç½®é—®é¢˜"
        return 1
    elif echo "$ssh_banner" | grep -qi "Host key verification failed"; then
        log_info "âœ“ SSH æœåŠ¡æ­£å¸¸å“åº”ï¼ˆä¸»æœºå¯†é’¥é—®é¢˜ï¼‰"
    else
        log_debug "SSH åè®®å“åº”: $(echo "$ssh_banner" | head -1)"
    fi
    
    # 5. æµ‹è¯•æ— å¯†ç è¿æ¥ï¼ˆæ£€æŸ¥æ˜¯å¦æœ‰å¯†é’¥è®¤è¯ï¼‰
    echo ""
    echo -e "${BLUE}[æ£€æŸ¥ 5/6]${NC} æµ‹è¯•å¯†é’¥è®¤è¯..."
    if ssh -o BatchMode=yes -o ConnectTimeout=3 -o StrictHostKeyChecking=no \
           -p "$ssh_port" "${ssh_user}@${remote_ip}" "echo 'SSH è¿æ¥æˆåŠŸ'" 2>/dev/null; then
        log_info "âœ“ å¯†é’¥è®¤è¯æˆåŠŸï¼ˆæ— éœ€å¯†ç ï¼‰"
        return 0
    else
        log_info "â—‹ å¯†é’¥è®¤è¯ä¸å¯ç”¨ï¼Œéœ€è¦å¯†ç è®¤è¯"
    fi
    
    # 6. æµ‹è¯•å¯†ç è®¤è¯
    echo ""
    echo -e "${BLUE}[æ£€æŸ¥ 6/6]${NC} æµ‹è¯•å¯†ç è®¤è¯..."
    
    # åˆ›å»ºä¸´æ—¶æ–‡ä»¶è®°å½•è¯¦ç»†é”™è¯¯
    local temp_log=$(mktemp)
    
    # å°è¯•è¿æ¥å¹¶æ•è·è¯¦ç»†è¾“å‡º
    sshpass -p "$remote_password" ssh \
        -o ConnectTimeout=5 \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o LogLevel=ERROR \
        -p "$ssh_port" \
        "${ssh_user}@${remote_ip}" \
        "echo 'SSH è¿æ¥æˆåŠŸ'" > "$temp_log" 2>&1
    
    local ssh_result=$?
    local ssh_output=$(cat "$temp_log")
    rm -f "$temp_log"
    
    # åˆ†æè¿”å›ç å’Œè¾“å‡º
    if [ $ssh_result -eq 0 ]; then
        log_info "âœ… å¯†ç è®¤è¯æˆåŠŸï¼"
        echo ""
        return 0
    else
        log_error "âœ— å¯†ç è®¤è¯å¤±è´¥"
        echo ""
        
        # è¯¦ç»†é”™è¯¯åˆ†æ
        echo -e "${YELLOW}é”™è¯¯åˆ†æï¼š${NC}"
        
        if echo "$ssh_output" | grep -qi "Permission denied"; then
            echo -e "${RED}â–º å¯†ç é”™è¯¯${NC}"
            echo ""
            echo "å¯èƒ½çš„åŸå› ï¼š"
            echo "  1. è¾“å…¥çš„å¯†ç ä¸æ­£ç¡®"
            echo "  2. ç”¨æˆ· '$ssh_user' ä¸å­˜åœ¨"
            echo "  3. ç”¨æˆ· '$ssh_user' è¢«ç¦ç”¨"
            echo "  4. SSH é…ç½®ç¦æ­¢å¯†ç ç™»å½• (PasswordAuthentication no)"
            echo ""
            echo "å»ºè®®æ“ä½œï¼š"
            echo "  1. ç¡®è®¤å¯†ç æ˜¯å¦æ­£ç¡®"
            echo "  2. æ£€æŸ¥è¿œç¨‹æœåŠ¡å™¨ /etc/ssh/sshd_configï¼š"
            echo "     PasswordAuthentication yes"
            echo "     PermitRootLogin yes  (å¦‚æœç”¨æˆ·æ˜¯ root)"
            
        elif echo "$ssh_output" | grep -qi "Connection refused"; then
            echo -e "${RED}â–º è¿æ¥è¢«æ‹’ç»${NC}"
            echo ""
            echo "å¯èƒ½çš„åŸå› ï¼š"
            echo "  1. SSH æœåŠ¡æœªè¿è¡Œ"
            echo "  2. ç«¯å£ $ssh_port ä¸æ­£ç¡®"
            echo ""
            echo "å»ºè®®æ“ä½œï¼š"
            echo "  åœ¨è¿œç¨‹æœåŠ¡å™¨è¿è¡Œï¼š"
            echo "    systemctl start sshd"
            echo "    systemctl enable sshd"
            
        elif echo "$ssh_output" | grep -qi "Connection timed out"; then
            echo -e "${RED}â–º è¿æ¥è¶…æ—¶${NC}"
            echo ""
            echo "å¯èƒ½çš„åŸå› ï¼š"
            echo "  1. é˜²ç«å¢™é˜»æ­¢äº† SSH è¿æ¥"
            echo "  2. ç½‘ç»œä¸é€š"
            echo "  3. IP åœ°å€é”™è¯¯"
            echo ""
            echo "å»ºè®®æ“ä½œï¼š"
            echo "  1. æ£€æŸ¥é˜²ç«å¢™è§„åˆ™"
            echo "  2. ping $remote_ip"
            echo "  3. ç¡®è®¤ IP åœ°å€æ­£ç¡®"
            
        elif echo "$ssh_output" | grep -qi "Network is unreachable\|No route to host"; then
            echo -e "${RED}â–º ç½‘ç»œä¸å¯è¾¾${NC}"
            echo ""
            echo "å¯èƒ½çš„åŸå› ï¼š"
            echo "  1. IP åœ°å€ä¸åœ¨åŒä¸€ç½‘æ®µ"
            echo "  2. è·¯ç”±é…ç½®é—®é¢˜"
            echo "  3. ç½‘å…³é…ç½®é”™è¯¯"
            echo ""
            echo "å»ºè®®æ“ä½œï¼š"
            echo "  1. æ£€æŸ¥ IP åœ°å€å’Œç½‘æ®µ"
            echo "  2. ip route get $remote_ip"
            echo "  3. æ£€æŸ¥ç½‘å…³é…ç½®"
            
        elif echo "$ssh_output" | grep -qi "Too many authentication failures"; then
            echo -e "${RED}â–º è®¤è¯å°è¯•æ¬¡æ•°è¿‡å¤š${NC}"
            echo ""
            echo "å¯èƒ½çš„åŸå› ï¼š"
            echo "  1. å¤šæ¬¡å¯†ç é”™è¯¯å¯¼è‡´æš‚æ—¶é”å®š"
            echo "  2. SSH é…ç½®é™åˆ¶äº†å°è¯•æ¬¡æ•°"
            echo ""
            echo "å»ºè®®æ“ä½œï¼š"
            echo "  1. ç­‰å¾…å‡ åˆ†é’Ÿåé‡è¯•"
            echo "  2. æ£€æŸ¥ /etc/ssh/sshd_config çš„ MaxAuthTries"
            
        elif echo "$ssh_output" | grep -qi "Host key verification failed"; then
            echo -e "${RED}â–º ä¸»æœºå¯†é’¥éªŒè¯å¤±è´¥${NC}"
            echo ""
            echo "å¯èƒ½çš„åŸå› ï¼š"
            echo "  1. è¿œç¨‹ä¸»æœºå¯†é’¥å·²æ›´æ”¹"
            echo "  2. å¯èƒ½å­˜åœ¨ä¸­é—´äººæ”»å‡»"
            echo ""
            echo "å»ºè®®æ“ä½œï¼š"
            echo "  1. åˆ é™¤æ—§çš„ä¸»æœºå¯†é’¥ï¼š"
            echo "     ssh-keygen -R $remote_ip"
            echo "  2. æˆ–ç¼–è¾‘ ~/.ssh/known_hosts"
            
        elif echo "$ssh_output" | grep -qi "Could not resolve hostname"; then
            echo -e "${RED}â–º æ— æ³•è§£æä¸»æœºå${NC}"
            echo ""
            echo "å¯èƒ½çš„åŸå› ï¼š"
            echo "  1. DNS è§£æå¤±è´¥"
            echo "  2. ä¸»æœºåé”™è¯¯"
            echo ""
            echo "å»ºè®®æ“ä½œï¼š"
            echo "  1. ä½¿ç”¨ IP åœ°å€è€Œéä¸»æœºå"
            echo "  2. æ£€æŸ¥ DNS é…ç½®"
            
        else
            echo -e "${RED}â–º æœªçŸ¥é”™è¯¯${NC}"
            echo ""
            echo "è¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼š"
            echo "$ssh_output" | head -5
            echo ""
            echo "è¿”å›ç : $ssh_result"
        fi
        
        echo ""
        echo -e "${CYAN}===============================================================${NC}"
        echo -e "${CYAN}  è¯Šæ–­æ‘˜è¦${NC}"
        echo -e "${CYAN}===============================================================${NC}"
        echo "ç›®æ ‡åœ°å€: ${ssh_user}@${remote_ip}:${ssh_port}"
        echo "è®¤è¯æ–¹å¼: å¯†ç è®¤è¯"
        echo "è¿æ¥çŠ¶æ€: å¤±è´¥"
        echo ""
        
        return 1
    fi
}

# é‡è¯•æœºåˆ¶
retry_ssh_connection() {
    local remote_ip="$1"
    local ssh_port="${2:-22}"
    local ssh_user="${3:-root}"
    local max_retries=3
    local retry_count=0
    
    while [ $retry_count -lt $max_retries ]; do
        echo ""
        if [ $retry_count -gt 0 ]; then
            echo -e "${YELLOW}ç¬¬ $((retry_count + 1)) æ¬¡å°è¯• (å…± $max_retries æ¬¡)${NC}"
        fi
        
        read -s -p "è¯·è¾“å…¥ SSH å¯†ç : " remote_password
        echo ""
        
        if [ -z "$remote_password" ]; then
            log_error "å¯†ç ä¸èƒ½ä¸ºç©ºï¼"
            retry_count=$((retry_count + 1))
            continue
        fi
        
        if test_ssh_connection "$remote_ip" "$remote_password" "$ssh_port" "$ssh_user"; then
            echo "$remote_password"
            return 0
        fi
        
        retry_count=$((retry_count + 1))
        
        if [ $retry_count -lt $max_retries ]; then
            echo ""
            read -p "æ˜¯å¦é‡è¯•ï¼Ÿ(y/n) [y]: " retry
            retry=${retry:-y}
            if [[ ! "$retry" =~ ^[Yy]$ ]]; then
                return 1
            fi
        fi
    done
    
    echo ""
    log_error "å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•° ($max_retries)"
    return 1
}

###########################################
# SNAT é…ç½®å‡½æ•°
###########################################

init_snat() {
    log_step "åˆå§‹åŒ– SNAT é…ç½®..."
    
    check_interface "$INTERNAL_IF"
    check_interface "$EXTERNAL_IF"
    
    INTERNAL_NETWORK=$(get_internal_network)
    EXTERNAL_IP=$(get_external_ip)
    LOCAL_ENS20_IP=$(get_internal_ip)
    
    log_info "å†…ç½‘ç½‘æ®µ: $INTERNAL_NETWORK"
    log_info "å†…ç½‘IP (ens20): $LOCAL_ENS20_IP"
    log_info "å¤–ç½‘IP (ens18): $EXTERNAL_IP"
    
    log_debug "å¯ç”¨IPè½¬å‘..."
    echo 1 > /proc/sys/net/ipv4/ip_forward
    
    if ! grep -q "^net.ipv4.ip_forward=1" /etc/sysctl.conf; then
        echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf
        sysctl -p > /dev/null 2>&1
    fi
    
    iptables -t nat -D POSTROUTING -s "$INTERNAL_NETWORK" -o "$EXTERNAL_IF" -j SNAT --to-source "$EXTERNAL_IP" 2>/dev/null
    
    log_debug "è®¾ç½®é»˜è®¤ç­–ç•¥..."
    iptables -P FORWARD DROP
    
    iptables -D FORWARD -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j LOG 2>/dev/null
    iptables -D FORWARD -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j REJECT 2>/dev/null
    
    if ! iptables -C FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT 2>/dev/null; then
        log_debug "å…è®¸å·²å»ºç«‹å’Œç›¸å…³çš„è¿æ¥..."
        iptables -I FORWARD 1 -m state --state ESTABLISHED,RELATED -j ACCEPT
    fi
    
    log_debug "é…ç½®å…è®¸è½¬å‘çš„IP..."
    for ip in "${ALLOWED_IPS[@]}"; do
        add_allowed_ip "$ip" "silent"
    done
    
    log_debug "é…ç½®æ‹’ç»å…¶ä»–IPçš„è½¬å‘..."
    if ! iptables -C FORWARD -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j LOG --log-prefix "FORWARD_REJECT: " 2>/dev/null; then
        iptables -A FORWARD -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j LOG --log-prefix "FORWARD_REJECT: " --log-level 4
    fi
    if ! iptables -C FORWARD -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j REJECT 2>/dev/null; then
        iptables -A FORWARD -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j REJECT --reject-with icmp-host-prohibited
    fi
    
    log_debug "é…ç½® SNAT è§„åˆ™..."
    iptables -t nat -A POSTROUTING -s "$INTERNAL_NETWORK" -o "$EXTERNAL_IF" -j SNAT --to-source "$EXTERNAL_IP"
    
    save_iptables
    
    log_info "âœ… SNAT é…ç½®å®Œæˆ"
}

add_allowed_ip() {
    local ip="$1"
    local mode="$2"
    
    if [ -z "$ip" ]; then
        log_error "è¯·æŒ‡å®šIPåœ°å€"
        return 1
    fi
    
    if ! validate_ip "$ip"; then
        log_error "æ— æ•ˆçš„IPåœ°å€æ ¼å¼: $ip"
        return 1
    fi
    
    if iptables -C FORWARD -s "$ip" -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j ACCEPT 2>/dev/null; then
        if [ "$mode" != "silent" ]; then
            log_warn "IP $ip å·²åœ¨å…è®¸åˆ—è¡¨ä¸­"
        fi
        return 0
    fi
    
    iptables -I FORWARD 2 -s "$ip" -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j ACCEPT
    
    if [ $? -eq 0 ]; then
        if [ "$mode" != "silent" ]; then
            log_info "âœ… å·²æ·»åŠ  $ip åˆ°å…è®¸è½¬å‘åˆ—è¡¨"
        fi
        return 0
    else
        log_error "æ·»åŠ  $ip å¤±è´¥"
        return 1
    fi
}

show_snat_summary() {
    print_header "SNAT é…ç½®æ‘˜è¦"
    
    INTERNAL_NETWORK=$(get_internal_network)
    EXTERNAL_IP=$(get_external_ip)
    LOCAL_ENS20_IP=$(get_internal_ip)
    
    echo -e "${CYAN}å†…ç½‘æ¥å£:${NC} $INTERNAL_IF"
    echo -e "  â€¢ IP: $LOCAL_ENS20_IP"
    echo -e "  â€¢ ç½‘æ®µ: $INTERNAL_NETWORK"
    echo -e "${CYAN}å¤–ç½‘æ¥å£:${NC} $EXTERNAL_IF ($EXTERNAL_IP)"
    echo -e "${CYAN}å…è®¸è½¬å‘çš„IP:${NC}"
    
    for ip in "${ALLOWED_IPS[@]}"; do
        echo "  â€¢ $ip"
    done
    
    echo ""
}

###########################################
# è¿œç¨‹ç­–ç•¥è·¯ç”±é…ç½®å‡½æ•°
###########################################

configure_remote_policy_routing() {
    print_header "è¿œç¨‹ç­–ç•¥è·¯ç”±é…ç½®"
    
    local remote_ip="$1"
    local remote_password="$2"
    local gateway_ip="$3"
    
    log_info "ç›®æ ‡æœåŠ¡å™¨: $remote_ip"
    log_info "ens20 ç½‘å…³å°†è®¾ç½®ä¸º: $gateway_ip (æœ¬æœº ens20)"
    
    local ssh_port=22
    local ssh_user="root"
    
    log_step "æµ‹è¯• SSH è¿æ¥..."
    
    if ! test_ssh_connection "$remote_ip" "$remote_password" "$ssh_port" "$ssh_user"; then
        return 1
    fi
    
    log_step "ç”Ÿæˆç­–ç•¥è·¯ç”±é…ç½®è„šæœ¬..."
    
    local temp_script="/tmp/remote_policy_routing_$$.sh"
    
    cat > "$temp_script" << 'EOF'
#!/bin/bash
# è¿œç¨‹æ‰§è¡Œçš„ç­–ç•¥è·¯ç”±é…ç½®è„šæœ¬

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

print_header() {
    echo -e "${BLUE}==============================================================${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}==============================================================${NC}"
}

print_success() {
    echo -e "${GREEN}   âœ… $1${NC}"
}

print_info() {
    echo -e "${YELLOW}   â„¹ï¸  $1${NC}"
}

print_error() {
    echo -e "${RED}   âŒ $1${NC}"
    exit 1
}

get_ip() {
    local interface=$1
    ip addr show $interface 2>/dev/null | grep 'inet ' | awk '{print $2}' | cut -d/ -f1 | head -n1
}

get_network() {
    local interface=$1
    ip addr show $interface 2>/dev/null | grep 'inet ' | awk '{print $2}' | head -n1
}

get_gateway() {
    local interface=$1
    ip route | grep "dev $interface" | grep via | awk '{print $3}' | head -n1
}

check_interface() {
    local interface=$1
    if ! ip link show $interface &>/dev/null; then
        print_error "ç½‘å¡ $interface ä¸å­˜åœ¨ï¼"
    fi
}

detect_system() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS=$ID
        VER=$VERSION_ID
    elif [ -f /etc/redhat-release ]; then
        OS="rhel"
    else
        OS="unknown"
    fi
    
    if systemctl is-active --quiet NetworkManager 2>/dev/null; then
        NETWORK_MANAGER="NetworkManager"
    elif systemctl is-active --quiet systemd-networkd 2>/dev/null; then
        NETWORK_MANAGER="systemd-networkd"
    elif [ -f /etc/network/interfaces ]; then
        NETWORK_MANAGER="interfaces"
    elif [ -d /etc/sysconfig/network-scripts ]; then
        NETWORK_MANAGER="network-scripts"
    else
        NETWORK_MANAGER="unknown"
    fi
    
    print_info "ç³»ç»Ÿ: $OS, ç½‘ç»œç®¡ç†: $NETWORK_MANAGER"
}

configure_dns() {
    print_info "é…ç½® DNS æœåŠ¡å™¨..."
    
    DNS1="1.1.1.1"
    DNS2="8.8.8.8"
    
    if [ -f /etc/resolv.conf ] && [ ! -f /etc/resolv.conf.backup ]; then
        cp /etc/resolv.conf /etc/resolv.conf.backup
        print_info "å·²å¤‡ä»½åŸ DNS é…ç½®åˆ° /etc/resolv.conf.backup"
    fi
    
    case "$NETWORK_MANAGER" in
        NetworkManager)
            configure_dns_networkmanager
            ;;
        systemd-networkd)
            configure_dns_systemd_networkd
            ;;
        *)
            configure_dns_generic
            ;;
    esac
    
    cat > /etc/resolv.conf << DNSEOF
# DNS Configuration - Managed by policy routing script
nameserver $DNS1
nameserver $DNS2
options timeout:2 attempts:3 rotate single-request-reopen
DNSEOF
    
    print_success "DNS å·²é…ç½®: $DNS1, $DNS2"
}

configure_dns_networkmanager() {
    print_info "ä½¿ç”¨ NetworkManager æŒä¹…åŒ– DNS..."
    
    if [ -f /etc/NetworkManager/NetworkManager.conf ]; then
        if ! grep -q "dns=none" /etc/NetworkManager/NetworkManager.conf; then
            sed -i '/\[main\]/a dns=none' /etc/NetworkManager/NetworkManager.conf
        fi
    fi
    
    if command -v nmcli &>/dev/null; then
        ACTIVE_CONN=$(nmcli -t -f NAME,DEVICE connection show --active | grep "ens20" | cut -d: -f1 | head -n1)
        if [ -n "$ACTIVE_CONN" ]; then
            nmcli connection modify "$ACTIVE_CONN" ipv4.dns "1.1.1.1 8.8.8.8" 2>/dev/null
            nmcli connection modify "$ACTIVE_CONN" ipv4.ignore-auto-dns yes 2>/dev/null
            print_info "å·²é€šè¿‡ NetworkManager è®¾ç½® DNS"
        fi
    fi
    
    chattr -i /etc/resolv.conf 2>/dev/null
    cat > /etc/resolv.conf << NMRESOLVEOF
# DNS Configuration - Protected
nameserver 1.1.1.1
nameserver 8.8.8.8
options timeout:2 attempts:3 rotate single-request-reopen
NMRESOLVEOF
    chattr +i /etc/resolv.conf 2>/dev/null
    
    print_success "NetworkManager DNS é…ç½®å®Œæˆ"
}

configure_dns_systemd_networkd() {
    print_info "ä½¿ç”¨ systemd-networkd æŒä¹…åŒ– DNS..."
    
    if [ -f /etc/systemd/resolved.conf ]; then
        cat > /etc/systemd/resolved.conf << RESOLVEDCONF
[Resolve]
DNS=1.1.1.1 8.8.8.8
FallbackDNS=1.0.0.1 8.8.4.4
DNSSEC=allow-downgrade
DNSOverTLS=no
RESOLVEDCONF
        
        systemctl restart systemd-resolved 2>/dev/null
        print_info "å·²é…ç½® systemd-resolved"
    fi
    
    if [ -L /etc/resolv.conf ]; then
        rm -f /etc/resolv.conf
    fi
    ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf 2>/dev/null || \
    cat > /etc/resolv.conf << SDRESOLVEOF
nameserver 1.1.1.1
nameserver 8.8.8.8
options timeout:2 attempts:3 rotate single-request-reopen
SDRESOLVEOF
    
    print_success "systemd-networkd DNS é…ç½®å®Œæˆ"
}

configure_dns_generic() {
    print_info "ä½¿ç”¨é€šç”¨æ–¹æ³•æŒä¹…åŒ– DNS..."
    
    cat > /usr/local/bin/setup-dns.sh << 'DNSSCRIPT'
#!/bin/bash
chattr -i /etc/resolv.conf 2>/dev/null
cat > /etc/resolv.conf << RESOLVEOF
# DNS Configuration - Auto configured
nameserver 1.1.1.1
nameserver 8.8.8.8
options timeout:2 attempts:3 rotate single-request-reopen
RESOLVEOF
chattr +i /etc/resolv.conf 2>/dev/null
logger "DNS é…ç½®å·²åº”ç”¨"
DNSSCRIPT

    chmod +x /usr/local/bin/setup-dns.sh
    /usr/local/bin/setup-dns.sh
    
    if [ -f /etc/rc.local ]; then
        if ! grep -q "setup-dns.sh" /etc/rc.local; then
            sed -i '/^exit 0/d' /etc/rc.local
            echo "/usr/local/bin/setup-dns.sh" >> /etc/rc.local
            echo "exit 0" >> /etc/rc.local
        fi
    fi
    
    if command -v systemctl &>/dev/null; then
        cat > /etc/systemd/system/dns-setup.service << 'DNSSERVICE'
[Unit]
Description=DNS Configuration
After=network.target
Before=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/setup-dns.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
DNSSERVICE
        
        systemctl daemon-reload
        systemctl enable dns-setup.service 2>/dev/null
        print_info "å·²åˆ›å»º DNS systemd æœåŠ¡"
    fi
    
    print_success "é€šç”¨ DNS é…ç½®å®Œæˆ"
}

persist_routes() {
    print_info "å¼€å§‹æŒä¹…åŒ–è·¯ç”±é…ç½®..."
    
    case "$NETWORK_MANAGER" in
        NetworkManager)
            persist_routes_networkmanager
            ;;
        systemd-networkd)
            persist_routes_systemd_networkd
            ;;
        interfaces)
            persist_routes_interfaces
            ;;
        *)
            persist_routes_generic
            ;;
    esac
}

persist_routes_networkmanager() {
    print_info "ä½¿ç”¨ NetworkManager æŒä¹…åŒ–è·¯ç”±..."
    
    mkdir -p /etc/NetworkManager/dispatcher.d
    
    cat > /etc/NetworkManager/dispatcher.d/99-policy-routing << 'NMSCRIPT'
#!/bin/bash
if [ "$2" = "up" ]; then
    sleep 2
    
    IX_IP=$(ip addr show ens18 2>/dev/null | grep 'inet ' | awk '{print $2}' | cut -d/ -f1 | head -n1)
    IX_GATEWAY=$(ip route | grep "dev ens18" | grep via | awk '{print $3}' | head -n1)
    ENS20_GATEWAY="__GATEWAY_IP__"
    
    IX_TABLE="ix_return"
    IX_TABLE_ID="100"
    IX_MARK="100"
    
    if ! grep -q "$IX_TABLE" /etc/iproute2/rt_tables; then
        echo "$IX_TABLE_ID $IX_TABLE" >> /etc/iproute2/rt_tables
    fi
    
    ip rule del from $IX_IP table $IX_TABLE 2>/dev/null
    ip rule add from $IX_IP table $IX_TABLE priority 100
    
    ip rule del fwmark $IX_MARK table $IX_TABLE 2>/dev/null
    ip rule add fwmark $IX_MARK table $IX_TABLE priority 99
    
    ip route flush table $IX_TABLE
    
    [ -n "$IX_GATEWAY" ] && ip route add default via $IX_GATEWAY dev ens18 table $IX_TABLE
    
    for iface in ens18 ens20 ens19; do
        if ip link show $iface &>/dev/null; then
            NETWORK=$(ip addr show $iface 2>/dev/null | grep 'inet ' | awk '{print $2}' | head -n1)
            SRC_IP=$(ip addr show $iface 2>/dev/null | grep 'inet ' | awk '{print $2}' | cut -d/ -f1 | head -n1)
            [ -n "$NETWORK" ] && [ -n "$SRC_IP" ] && ip route add $NETWORK dev $iface src $SRC_IP table $IX_TABLE
        fi
    done
    
    ip route del default 2>/dev/null
    ip route add default via $ENS20_GATEWAY dev ens20
    ip route flush cache 2>/dev/null
    
    /usr/local/bin/setup-dns.sh 2>/dev/null
fi
NMSCRIPT
    
    sed -i "s/__GATEWAY_IP__/$ENS20_GATEWAY/g" /etc/NetworkManager/dispatcher.d/99-policy-routing
    chmod +x /etc/NetworkManager/dispatcher.d/99-policy-routing
    print_success "NetworkManager dispatcher è„šæœ¬å·²åˆ›å»º"
}

persist_routes_systemd_networkd() {
    print_info "ä½¿ç”¨ systemd-networkd æŒä¹…åŒ–è·¯ç”±..."
    
    cat > /usr/local/bin/setup-policy-routing.sh << 'SDSCRIPT'
#!/bin/bash
IX_IP=$(ip addr show ens18 2>/dev/null | grep 'inet ' | awk '{print $2}' | cut -d/ -f1 | head -n1)
IX_GATEWAY=$(ip route | grep "dev ens18" | grep via | awk '{print $3}' | head -n1)
ENS20_GATEWAY="__GATEWAY_IP__"

IX_TABLE="ix_return"
IX_TABLE_ID="100"
IX_MARK="100"

if ! grep -q "$IX_TABLE" /etc/iproute2/rt_tables; then
    echo "$IX_TABLE_ID $IX_TABLE" >> /etc/iproute2/rt_tables
fi

ip rule del from $IX_IP table $IX_TABLE 2>/dev/null
ip rule add from $IX_IP table $IX_TABLE priority 100

ip rule del fwmark $IX_MARK table $IX_TABLE 2>/dev/null
ip rule add fwmark $IX_MARK table $IX_TABLE priority 99

ip route flush table $IX_TABLE

[ -n "$IX_GATEWAY" ] && ip route add default via $IX_GATEWAY dev ens18 table $IX_TABLE

for iface in ens18 ens20 ens19; do
    if ip link show $iface &>/dev/null; then
        NETWORK=$(ip addr show $iface 2>/dev/null | grep 'inet ' | awk '{print $2}' | head -n1)
        SRC_IP=$(ip addr show $iface 2>/dev/null | grep 'inet ' | awk '{print $2}' | cut -d/ -f1 | head -n1)
        [ -n "$NETWORK" ] && [ -n "$SRC_IP" ] && ip route add $NETWORK dev $iface src $SRC_IP table $IX_TABLE
    fi
done

ip route del default 2>/dev/null
ip route add default via $ENS20_GATEWAY dev ens20
ip route flush cache 2>/dev/null
SDSCRIPT

    sed -i "s/__GATEWAY_IP__/$ENS20_GATEWAY/g" /usr/local/bin/setup-policy-routing.sh
    chmod +x /usr/local/bin/setup-policy-routing.sh
    
    cat > /etc/systemd/system/policy-routing.service << 'SDSERVICE'
[Unit]
Description=Policy Routing Configuration
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/local/bin/setup-policy-routing.sh

[Install]
WantedBy=multi-user.target
SDSERVICE

    systemctl daemon-reload
    systemctl enable policy-routing.service
    print_success "systemd-networkd é…ç½®å·²åˆ›å»º"
}

persist_routes_interfaces() {
    print_info "ä½¿ç”¨ /etc/network/interfaces æŒä¹…åŒ–è·¯ç”±..."
    
    mkdir -p /etc/network/if-up.d
    
    cat > /etc/network/if-up.d/policy-routing << 'IFSCRIPT'
#!/bin/bash
if [ "$IFACE" = "ens20" ] || [ "$IFACE" = "ens18" ]; then
    sleep 2
    
    IX_IP=$(ip addr show ens18 2>/dev/null | grep 'inet ' | awk '{print $2}' | cut -d/ -f1 | head -n1)
    IX_GATEWAY=$(ip route | grep "dev ens18" | grep via | awk '{print $3}' | head -n1)
    ENS20_GATEWAY="__GATEWAY_IP__"
    
    IX_TABLE="ix_return"
    IX_TABLE_ID="100"
    IX_MARK="100"
    
    if ! grep -q "$IX_TABLE" /etc/iproute2/rt_tables; then
        echo "$IX_TABLE_ID $IX_TABLE" >> /etc/iproute2/rt_tables
    fi
    
    ip rule del from $IX_IP table $IX_TABLE 2>/dev/null
    ip rule add from $IX_IP table $IX_TABLE priority 100
    
    ip rule del fwmark $IX_MARK table $IX_TABLE 2>/dev/null
    ip rule add fwmark $IX_MARK table $IX_TABLE priority 99
    
    ip route flush table $IX_TABLE
    
    [ -n "$IX_GATEWAY" ] && ip route add default via $IX_GATEWAY dev ens18 table $IX_TABLE
    
    for iface in ens18 ens20 ens19; do
        if ip link show $iface &>/dev/null; then
            NETWORK=$(ip addr show $iface 2>/dev/null | grep 'inet ' | awk '{print $2}' | head -n1)
            SRC_IP=$(ip addr show $iface 2>/dev/null | grep 'inet ' | awk '{print $2}' | cut -d/ -f1 | head -n1)
            [ -n "$NETWORK" ] && [ -n "$SRC_IP" ] && ip route add $NETWORK dev $iface src $SRC_IP table $IX_TABLE
        fi
    done
    
    ip route del default 2>/dev/null
    ip route add default via $ENS20_GATEWAY dev ens20
    ip route flush cache 2>/dev/null
    
    /usr/local/bin/setup-dns.sh 2>/dev/null
fi
IFSCRIPT

    sed -i "s/__GATEWAY_IP__/$ENS20_GATEWAY/g" /etc/network/if-up.d/policy-routing
    chmod +x /etc/network/if-up.d/policy-routing
    print_success "/etc/network/if-up.d è„šæœ¬å·²åˆ›å»º"
}

persist_routes_generic() {
    print_info "ä½¿ç”¨ rc.local æŒä¹…åŒ–è·¯ç”±..."
    
    cat > /usr/local/bin/setup-policy-routing.sh << 'RCSCRIPT'
#!/bin/bash
sleep 3

IX_IP=$(ip addr show ens18 2>/dev/null | grep 'inet ' | awk '{print $2}' | cut -d/ -f1 | head -n1)
IX_GATEWAY=$(ip route | grep "dev ens18" | grep via | awk '{print $3}' | head -n1)
ENS20_GATEWAY="__GATEWAY_IP__"

IX_TABLE="ix_return"
IX_TABLE_ID="100"
IX_MARK="100"

if ! grep -q "$IX_TABLE" /etc/iproute2/rt_tables; then
    echo "$IX_TABLE_ID $IX_TABLE" >> /etc/iproute2/rt_tables
fi

ip rule del from $IX_IP table $IX_TABLE 2>/dev/null
ip rule add from $IX_IP table $IX_TABLE priority 100

ip rule del fwmark $IX_MARK table $IX_TABLE 2>/dev/null
ip rule add fwmark $IX_MARK table $IX_TABLE priority 99

ip route flush table $IX_TABLE

[ -n "$IX_GATEWAY" ] && ip route add default via $IX_GATEWAY dev ens18 table $IX_TABLE

for iface in ens18 ens20 ens19; do
    if ip link show $iface &>/dev/null; then
        NETWORK=$(ip addr show $iface 2>/dev/null | grep 'inet ' | awk '{print $2}' | head -n1)
        SRC_IP=$(ip addr show $iface 2>/dev/null | grep 'inet ' | awk '{print $2}' | cut -d/ -f1 | head -n1)
        [ -n "$NETWORK" ] && [ -n "$SRC_IP" ] && ip route add $NETWORK dev $iface src $SRC_IP table $IX_TABLE
    fi
done

ip route del default 2>/dev/null
ip route add default via $ENS20_GATEWAY dev ens20

ip route flush cache 2>/dev/null
logger "ç­–ç•¥è·¯ç”±é…ç½®å·²åº”ç”¨"
RCSCRIPT

    sed -i "s/__GATEWAY_IP__/$ENS20_GATEWAY/g" /usr/local/bin/setup-policy-routing.sh
    chmod +x /usr/local/bin/setup-policy-routing.sh
    
    if [ -f /etc/rc.local ]; then
        if ! grep -q "setup-policy-routing.sh" /etc/rc.local; then
            sed -i '/^exit 0/d' /etc/rc.local
            echo "/usr/local/bin/setup-policy-routing.sh &" >> /etc/rc.local
            echo "/usr/local/bin/setup-dns.sh &" >> /etc/rc.local
            echo "exit 0" >> /etc/rc.local
        fi
        chmod +x /etc/rc.local
    else
        cat > /etc/rc.local << 'RCLOCALFILE'
#!/bin/bash
/usr/local/bin/setup-policy-routing.sh &
/usr/local/bin/setup-dns.sh &
exit 0
RCLOCALFILE
        chmod +x /etc/rc.local
    fi
    
    if command -v systemctl &>/dev/null; then
        cat > /etc/systemd/system/rc-local.service << 'RCLOCALSERVICE'
[Unit]
Description=/etc/rc.local Compatibility
ConditionPathExists=/etc/rc.local
After=network-online.target
Wants=network-online.target

[Service]
Type=forking
ExecStart=/etc/rc.local start
TimeoutSec=0
StandardOutput=tty
RemainAfterExit=yes
SysVStartPriority=99

[Install]
WantedBy=multi-user.target
RCLOCALSERVICE
        
        systemctl daemon-reload
        systemctl enable rc-local.service 2>/dev/null
    fi
    
    print_success "rc.local é…ç½®å·²åˆ›å»º"
}

persist_iptables() {
    print_info "æŒä¹…åŒ– iptables è§„åˆ™..."
    
    mkdir -p /etc/iptables
    iptables-save > /etc/iptables/rules.v4
    
    if command -v systemctl &>/dev/null; then
        if ! systemctl list-unit-files | grep -q "iptables-persistent\|netfilter-persistent"; then
            cat > /etc/systemd/system/iptables-restore.service << 'IPTSERVICE'
[Unit]
Description=Restore iptables rules
Before=network-pre.target
Wants=network-pre.target

[Service]
Type=oneshot
ExecStart=/sbin/iptables-restore /etc/iptables/rules.v4

[Install]
WantedBy=multi-user.target
IPTSERVICE
            
            systemctl daemon-reload
            systemctl enable iptables-restore.service 2>/dev/null
        fi
    fi
    
    print_success "iptables è§„åˆ™å·²æŒä¹…åŒ–"
}

persist_sysctl() {
    print_info "æŒä¹…åŒ– sysctl é…ç½®..."
    
    cat > /etc/sysctl.d/99-policy-routing.conf << 'SYSCTLCONF'
net.ipv4.conf.ens18.rp_filter=2
net.ipv4.conf.ens20.rp_filter=2
net.ipv4.conf.all.rp_filter=2
net.ipv4.ip_forward=1
SYSCTLCONF
    
    sysctl -p /etc/sysctl.d/99-policy-routing.conf > /dev/null 2>&1
    print_success "sysctl é…ç½®å·²æŒä¹…åŒ–"
}

configure_policy_routing() {
    print_header "å¼€å§‹é…ç½®ç­–ç•¥è·¯ç”±"
    
    if [ "$EUID" -ne 0 ]; then 
        print_error "éœ€è¦ root æƒé™"
    fi
    
    detect_system
    
    echo ""
    echo "ã€æ­¥éª¤1ã€‘æ£€æŸ¥ç½‘å¡..."
    check_interface "ens18"
    print_success "ens18 å­˜åœ¨"
    check_interface "ens20"
    print_success "ens20 å­˜åœ¨"
    
    HAS_ENS19=false
    if ip link show ens19 &>/dev/null; then
        HAS_ENS19=true
        print_success "ens19 å­˜åœ¨"
    else
        print_info "ens19 ä¸å­˜åœ¨ï¼ˆè·³è¿‡ï¼‰"
    fi
    
    echo ""
    echo "ã€æ­¥éª¤2ã€‘è¯»å– ens18 (IX) é…ç½®..."
    IX_IP=$(get_ip "ens18")
    [ -z "$IX_IP" ] && print_error "æ— æ³•è¯»å– ens18 çš„ IP åœ°å€ï¼"
    print_success "IX IP: $IX_IP"
    
    IX_GATEWAY=$(get_gateway "ens18")
    if [ -z "$IX_GATEWAY" ]; then
        IX_NETWORK=$(ip addr show ens18 2>/dev/null | grep 'inet ' | awk '{print $2}' | head -n1)
        IX_GATEWAY=$(echo $IX_NETWORK | awk -F'.' '{print $1"."$2"."$3".1"}')
        print_info "è‡ªåŠ¨æ¨ç®—ç½‘å…³: $IX_GATEWAY"
    else
        print_success "æ£€æµ‹åˆ°ç½‘å…³: $IX_GATEWAY"
    fi
    
    ENS18_NETWORK=$(get_network "ens18")
    print_success "IX ç½‘æ®µ: $ENS18_NETWORK"
    
    echo ""
    echo "ã€æ­¥éª¤3ã€‘è¯»å– ens20 é…ç½®..."
    ENS20_IP=$(get_ip "ens20")
    ENS20_NETWORK=$(get_network "ens20")
    print_success "ens20 IP: $ENS20_IP"
    print_success "ens20 ç½‘æ®µ: $ENS20_NETWORK"
    
    ENS20_GATEWAY="__GATEWAY_IP__"
    print_success "ens20 Gateway: $ENS20_GATEWAY (SNAT æœåŠ¡å™¨)"
    
    if [ "$HAS_ENS19" = true ]; then
        echo ""
        echo "ã€æ­¥éª¤4ã€‘è¯»å– ens19 é…ç½®..."
        ENS19_IP=$(get_ip "ens19")
        ENS19_NETWORK=$(get_network "ens19")
        print_success "ens19 IP: $ENS19_IP"
        print_success "ens19 ç½‘æ®µ: $ENS19_NETWORK"
    fi
    
    echo ""
    echo "ã€æ­¥éª¤5ã€‘é…ç½® DNS..."
    configure_dns
    
    IX_TABLE="ix_return"
    IX_TABLE_ID="100"
    IX_MARK="100"
    
    echo ""
    echo "ã€æ­¥éª¤6ã€‘åˆ›å»ºè·¯ç”±è¡¨..."
    if ! grep -q "$IX_TABLE" /etc/iproute2/rt_tables; then
        echo "$IX_TABLE_ID $IX_TABLE" >> /etc/iproute2/rt_tables
        print_success "è·¯ç”±è¡¨ $IX_TABLE å·²åˆ›å»º"
    else
        print_info "è·¯ç”±è¡¨ $IX_TABLE å·²å­˜åœ¨"
    fi
    
    echo ""
    echo "ã€æ­¥éª¤7ã€‘æ¸…ç†ç°æœ‰è·¯ç”±é…ç½®..."
    ip route del default via $IX_GATEWAY dev ens18 2>/dev/null
    while ip rule del from $IX_IP table $IX_TABLE 2>/dev/null; do :; done
    while ip rule del fwmark $IX_MARK table $IX_TABLE 2>/dev/null; do :; done
    ip route flush table $IX_TABLE
    print_success "æ—§é…ç½®å·²æ¸…ç†"
    
    echo ""
    echo "ã€æ­¥éª¤8ã€‘é…ç½®æ–°è·¯ç”±..."
    ip route del default 2>/dev/null
    ip route add default via $ENS20_GATEWAY dev ens20
    print_success "é»˜è®¤è·¯ç”±: ens20 -> $ENS20_GATEWAY"
    
    ip route add default via $IX_GATEWAY dev ens18 table $IX_TABLE
    print_success "IX å›ç¨‹é»˜è®¤è·¯ç”±: ens18 -> $IX_GATEWAY"
    
    ip route add $ENS18_NETWORK dev ens18 src $IX_IP table $IX_TABLE
    print_success "æ·»åŠ è·¯ç”±: $ENS18_NETWORK via ens18"
    
    ip route add $ENS20_NETWORK dev ens20 src $ENS20_IP table $IX_TABLE
    print_success "æ·»åŠ è·¯ç”±: $ENS20_NETWORK via ens20"
    
    if [ "$HAS_ENS19" = true ] && [ -n "$ENS19_IP" ]; then
        ip route add $ENS19_NETWORK dev ens19 src $ENS19_IP table $IX_TABLE
        print_success "æ·»åŠ è·¯ç”±: $ENS19_NETWORK via ens19"
    fi
    
    echo ""
    echo "ã€æ­¥éª¤9ã€‘æ·»åŠ ç­–ç•¥è·¯ç”±è§„åˆ™..."
    ip rule add from $IX_IP table $IX_TABLE priority 100
    print_success "è§„åˆ™: from $IX_IP use table $IX_TABLE (priority 100)"
    
    ip rule add fwmark $IX_MARK table $IX_TABLE priority 99
    print_success "è§„åˆ™: fwmark $IX_MARK use table $IX_TABLE (priority 99)"
    
    echo ""
    echo "ã€æ­¥éª¤10ã€‘é…ç½® iptables è¿æ¥è·Ÿè¸ª..."
    iptables -t mangle -D PREROUTING -i ens18 -j CONNMARK --set-mark $IX_MARK 2>/dev/null
    iptables -t mangle -D OUTPUT -j CONNMARK --restore-mark 2>/dev/null
    iptables -t mangle -A PREROUTING -i ens18 -j CONNMARK --set-mark $IX_MARK
    iptables -t mangle -A OUTPUT -j CONNMARK --restore-mark
    print_success "è¿æ¥è·Ÿè¸ªå·²é…ç½®"
    
    echo ""
    echo "ã€æ­¥éª¤11ã€‘è°ƒæ•´ç³»ç»Ÿå‚æ•°..."
    sysctl -w net.ipv4.conf.ens18.rp_filter=2 > /dev/null
    sysctl -w net.ipv4.conf.ens20.rp_filter=2 > /dev/null
    sysctl -w net.ipv4.conf.all.rp_filter=2 > /dev/null
    print_success "rp_filter å·²è®¾ç½®ä¸ºå®½æ¾æ¨¡å¼(2)"
    
    ip route flush cache 2>/dev/null
    print_success "è·¯ç”±ç¼“å­˜å·²åˆ·æ–°"
    
    echo ""
    echo "ã€æ­¥éª¤12ã€‘æŒä¹…åŒ–é…ç½®..."
    persist_sysctl
    persist_iptables
    persist_routes
    print_success "æ‰€æœ‰é…ç½®å·²æŒä¹…åŒ–"
    
    echo ""
    print_header "ç­–ç•¥è·¯ç”±é…ç½®å®Œæˆï¼"
    echo ""
    echo "ğŸ“Œ ç½‘å¡é…ç½®ï¼š"
    echo "   â€¢ ens18 (IX): $IX_IP / $ENS18_NETWORK -> $IX_GATEWAY"
    echo "   â€¢ ens20: $ENS20_IP / $ENS20_NETWORK -> $ENS20_GATEWAY (SNATæœåŠ¡å™¨)"
    [ "$HAS_ENS19" = true ] && echo "   â€¢ ens19: $ENS19_IP / $ENS19_NETWORK"
    echo ""
    echo "ğŸ“Œ DNS é…ç½®ï¼š"
    echo "   â€¢ ä¸» DNS: 1.1.1.1 (Cloudflare)"
    echo "   â€¢ å¤‡ DNS: 8.8.8.8 (Google)"
    echo ""
    echo "ğŸ“Œ è·¯ç”±ç­–ç•¥ï¼š"
    echo "   â€¢ é»˜è®¤å‡ºç«™: ens20 -> $ENS20_GATEWAY (é€šè¿‡SNATæœåŠ¡å™¨)"
    echo "   â€¢ IX å›ç¨‹: ens18 -> $IX_GATEWAY"
    echo ""
    echo "ğŸ“Œ æŒä¹…åŒ–æ–¹å¼ï¼š"
    echo "   â€¢ ç³»ç»Ÿ: $OS"
    echo "   â€¢ ç½‘ç»œç®¡ç†: $NETWORK_MANAGER"
    echo "   â€¢ é…ç½®å·²åœ¨ç³»ç»Ÿé‡å¯åè‡ªåŠ¨ç”Ÿæ•ˆ"
    echo ""
}

configure_policy_routing
EOF

    sed -i "s/__GATEWAY_IP__/$gateway_ip/g" "$temp_script"
    
    log_step "æ‰§è¡Œè¿œç¨‹ç­–ç•¥è·¯ç”±é…ç½®..."
    echo ""
    
    if sshpass -p "$remote_password" ssh -o StrictHostKeyChecking=no -p $ssh_port ${ssh_user}@${remote_ip} "bash -s" < "$temp_script" 2>&1; then
        echo ""
        log_info "âœ… è¿œç¨‹ç­–ç•¥è·¯ç”±é…ç½®æˆåŠŸï¼"
        rm -f "$temp_script"
        return 0
    else
        echo ""
        log_error "è¿œç¨‹é…ç½®å¤±è´¥ï¼"
        rm -f "$temp_script"
        return 1
    fi
}

###########################################
# æ¸…ç†ç­–ç•¥è·¯ç”±å‡½æ•°
###########################################

clean_policy_routing() {
    check_root
    
    print_header "æ¸…ç©ºç­–ç•¥è·¯ç”±é…ç½®"
    
    echo -e "${YELLOW}è­¦å‘Šï¼šæ­¤æ“ä½œå°†æ¸…ç©ºä»¥ä¸‹é…ç½®ï¼š${NC}"
    echo "  â€¢ ix_return è·¯ç”±è¡¨"
    echo "  â€¢ ç­–ç•¥è·¯ç”±è§„åˆ™"
    echo "  â€¢ iptables mangle è§„åˆ™"
    echo "  â€¢ é»˜è®¤è·¯ç”±ï¼ˆå¯é€‰ï¼‰"
    echo ""
    
    read -p "ç¡®å®šè¦æ¸…ç©ºå—ï¼Ÿ(yes/no) [no]: " confirm
    confirm=${confirm:-no}
    
    if [ "$confirm" != "yes" ]; then
        log_warn "æ“ä½œå·²å–æ¶ˆ"
        return 0
    fi
    
    echo ""
    log_step "å¼€å§‹æ¸…ç†..."
    
    log_info "æ¸…ç©º ix_return è·¯ç”±è¡¨..."
    ip route flush table ix_return 2>/dev/null
    
    log_info "åˆ é™¤ç­–ç•¥è·¯ç”±è§„åˆ™..."
    while ip rule list | grep -q "100:"; do
        ip rule del priority 100 2>/dev/null
    done
    
    while ip rule list | grep -q "99:"; do
        ip rule del priority 99 2>/dev/null
    done
    
    log_info "æ¸…ç©º iptables mangle è§„åˆ™..."
    iptables -t mangle -F PREROUTING 2>/dev/null
    iptables -t mangle -F OUTPUT 2>/dev/null
    iptables -t mangle -X 2>/dev/null
    
    read -p "æ˜¯å¦æ¸…ç©ºé»˜è®¤è·¯ç”±ï¼Ÿ(y/n) [n]: " clear_default
    if [[ "$clear_default" =~ ^[Yy]$ ]]; then
        log_info "æ¸…ç©ºé»˜è®¤è·¯ç”±..."
        ip route del default 2>/dev/null
    fi
    
    log_info "åˆ·æ–°è·¯ç”±ç¼“å­˜..."
    ip route flush cache 2>/dev/null
    
    save_iptables
    
    echo ""
    log_info "âœ… æ¸…ç†å®Œæˆï¼"
    echo ""
    
    echo "å½“å‰è·¯ç”±è§„åˆ™ï¼š"
    ip rule list
    echo ""
    
    echo "å½“å‰é»˜è®¤è·¯ç”±ï¼š"
    ip route show default
    echo ""
    
    echo "ix_return è·¯ç”±è¡¨ï¼š"
    ip route show table ix_return
    echo ""
}

###########################################
# äº¤äº’å¼é…ç½®ä¸»æµç¨‹
###########################################

interactive_setup() {
    check_root
    
    print_header "Halocloud IX SNAT + ç­–ç•¥è·¯ç”±é…ç½®è„šæœ¬ v2.1"
    
    check_interface "$INTERNAL_IF"
    LOCAL_ENS20_IP=$(get_internal_ip)
    
    log_info "æœ¬æœº ens20 IP: $LOCAL_ENS20_IP"
    log_info "æ­¤ IP å°†ä½œä¸º IX ç«¯ ens20 çš„ç½‘å…³"
    
    echo ""
    log_step "æ­¥éª¤ 1/3: é…ç½®è¿œç¨‹ IX æœåŠ¡å™¨"
    echo ""
    
    read -p "è¯·è¾“å…¥ IX æœåŠ¡å™¨çš„ IP åœ°å€: " IX_SERVER_IP
    if [ -z "$IX_SERVER_IP" ]; then
        log_error "IP åœ°å€ä¸èƒ½ä¸ºç©ºï¼"
        exit 1
    fi
    
    if ! validate_ip "$IX_SERVER_IP"; then
        log_error "æ— æ•ˆçš„ IP åœ°å€æ ¼å¼ï¼"
        exit 1
    fi
    
    IX_SERVER_PASSWORD=$(retry_ssh_connection "$IX_SERVER_IP")
    if [ $? -ne 0 ] || [ -z "$IX_SERVER_PASSWORD" ]; then
        log_error "æ— æ³•å»ºç«‹ SSH è¿æ¥"
        exit 1
    fi
    
    ALLOWED_IPS+=("$IX_SERVER_IP")
    log_info "âœ… IX IP $IX_SERVER_IP å·²è‡ªåŠ¨æ·»åŠ åˆ°å…è®¸åˆ—è¡¨"
    
    echo ""
    log_step "æ­¥éª¤ 2/3: é…ç½®å…è®¸è½¬å‘çš„ IP åœ°å€"
    echo ""
    log_info "IX IP ($IX_SERVER_IP) å·²è‡ªåŠ¨æ·»åŠ "
    echo ""
    
    echo ""
    log_step "æ­¥éª¤ 3/3: ç¡®è®¤é…ç½®"
    echo ""
    echo -e "${CYAN}é…ç½®æ‘˜è¦:${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "  ${YELLOW}æœ¬æœº (SNAT æœåŠ¡å™¨):${NC}"
    echo "    ens20 IP: $LOCAL_ENS20_IP"
    echo "    ens18 (å…¬ç½‘å‡ºå£): $(get_external_ip 2>/dev/null || echo 'å¾…æ£€æµ‹')"
    echo ""
    echo -e "  ${YELLOW}è¿œç¨‹ IX æœåŠ¡å™¨:${NC}"
    echo "    IP: $IX_SERVER_IP"
    echo "    ens20 ç½‘å…³å°†è®¾ç½®ä¸º: ${GREEN}$LOCAL_ENS20_IP${NC} (æœ¬æœº)"
    echo "    DNS: 1.1.1.1, 8.8.8.8"
    echo "    å°†é…ç½®ç­–ç•¥è·¯ç”±å¹¶æŒä¹…åŒ–"
    echo ""
    echo -e "  ${YELLOW}å…è®¸è½¬å‘çš„ IP åˆ—è¡¨:${NC}"
    for ip in "${ALLOWED_IPS[@]}"; do
        if [ "$ip" == "$IX_SERVER_IP" ]; then
            echo "    â€¢ $ip ${GREEN}(IX Server)${NC}"
        else
            echo "    â€¢ $ip"
        fi
    done
    echo ""
    echo -e "  ${YELLOW}ç½‘ç»œæ‹“æ‰‘:${NC}"
    echo "    IX Server (ens20) -> $LOCAL_ENS20_IP (æœ¬æœº ens20) -> å…¬ç½‘ (ens18)"
    echo ""
    echo -e "  ${YELLOW}æŒä¹…åŒ–é…ç½®:${NC}"
    echo "    â€¢ IX ç«¯è·¯ç”±è§„åˆ™å°†åœ¨é‡å¯åè‡ªåŠ¨æ¢å¤"
    echo "    â€¢ IX ç«¯ DNS é…ç½®å°†åœ¨é‡å¯åè‡ªåŠ¨æ¢å¤"
    echo "    â€¢ æœ¬åœ° SNAT è§„åˆ™å°†åœ¨é‡å¯åè‡ªåŠ¨æ¢å¤"
    echo ""
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    
    read -p "ç¡®è®¤å¼€å§‹é…ç½®ï¼Ÿ(yes/no) [yes]: " confirm
    confirm=${confirm:-yes}
    
    if [ "$confirm" != "yes" ]; then
        log_warn "é…ç½®å·²å–æ¶ˆ"
        exit 0
    fi
    
    echo ""
    print_header "å¼€å§‹æ‰§è¡Œé…ç½®"
    
    echo ""
    log_step "ã€é˜¶æ®µ 1/2ã€‘é…ç½®æœ¬åœ° SNAT..."
    echo ""
    init_snat
    save_iptables
    
    show_snat_summary
    
    echo ""
    log_step "ã€é˜¶æ®µ 2/2ã€‘é…ç½®è¿œç¨‹ç­–ç•¥è·¯ç”±ã€DNS å¹¶æŒä¹…åŒ–..."
    echo ""
    
    if configure_remote_policy_routing "$IX_SERVER_IP" "$IX_SERVER_PASSWORD" "$LOCAL_ENS20_IP"; then
        print_header "ğŸ‰ å…¨éƒ¨é…ç½®å®Œæˆï¼"
        echo ""
        echo -e "${GREEN}âœ… æœ¬åœ° SNAT é…ç½®æˆåŠŸ${NC}"
        echo -e "${GREEN}âœ… è¿œç¨‹ç­–ç•¥è·¯ç”±é…ç½®æˆåŠŸ${NC}"
        echo -e "${GREEN}âœ… è¿œç¨‹ DNS é…ç½®æˆåŠŸ${NC}"
        echo -e "${GREEN}âœ… æ‰€æœ‰é…ç½®å·²æŒä¹…åŒ–${NC}"
        echo ""
        echo -e "${CYAN}é…ç½®è¯¦æƒ…:${NC}"
        echo "  â€¢ æœ¬æœº ens20 IP: $LOCAL_ENS20_IP"
        echo "  â€¢ å…è®¸è½¬å‘çš„ IP æ•°é‡: ${#ALLOWED_IPS[@]}"
        echo "  â€¢ è¿œç¨‹ IX æœåŠ¡å™¨: $IX_SERVER_IP"
        echo "  â€¢ IX ens20 ç½‘å…³: $LOCAL_ENS20_IP (æŒ‡å‘æœ¬æœº)"
        echo "  â€¢ IX DNS: 1.1.1.1, 8.8.8.8"
        echo ""
        echo -e "${CYAN}æµé‡è·¯å¾„:${NC}"
        echo "  ${YELLOW}ä¸»åŠ¨å‡ºç«™:${NC} IX Server -> æœ¬æœº ens20 ($LOCAL_ENS20_IP) -> SNAT -> å…¬ç½‘ (ens18)"
        echo "  ${YELLOW}IX å›ç¨‹:${NC} å…¬ç½‘ -> IX Server ens18 -> åŸè·¯è¿”å›"
        echo ""
        echo -e "${CYAN}æŒä¹…åŒ–çŠ¶æ€:${NC}"
        echo "  ${GREEN}âœ“${NC} æœ¬åœ° iptables è§„åˆ™å·²ä¿å­˜"
        echo "  ${GREEN}âœ“${NC} è¿œç¨‹è·¯ç”±è§„åˆ™å·²é…ç½®å¼€æœºè‡ªå¯"
        echo "  ${GREEN}âœ“${NC} è¿œç¨‹ DNS å·²é…ç½®å¼€æœºè‡ªå¯"
        echo "  ${GREEN}âœ“${NC} ç³»ç»Ÿé‡å¯åè‡ªåŠ¨æ¢å¤é…ç½®"
        echo ""
        echo -e "${YELLOW}éªŒè¯å‘½ä»¤ (åœ¨ IX ç«¯è¿è¡Œ):${NC}"
        echo "  â€¢ æµ‹è¯• DNS: nslookup google.com"
        echo "  â€¢ æµ‹è¯•ç½‘å…³: ping $LOCAL_ENS20_IP"
        echo "  â€¢ æŸ¥çœ‹è·¯ç”±: ip route"
        echo "  â€¢ æŸ¥çœ‹ DNS: cat /etc/resolv.conf"
        echo ""
        echo -e "${YELLOW}æ³¨æ„äº‹é¡¹:${NC}"
        echo "  â€¢ æ‰€æœ‰é…ç½®å·²è‡ªåŠ¨ä¿å­˜å¹¶æŒä¹…åŒ–"
        echo "  â€¢ DNS é…ç½®å·²é”å®šï¼Œé˜²æ­¢è¢«è¦†ç›–"
        echo "  â€¢ å¦‚éœ€æ·»åŠ æ›´å¤š IPï¼Œè¯·ä½¿ç”¨: $0 add <IP>"
        echo ""
    else
        echo ""
        log_warn "æœ¬åœ° SNAT é…ç½®æˆåŠŸï¼Œä½†è¿œç¨‹ç­–ç•¥è·¯ç”±é…ç½®å¤±è´¥"
        log_info "æ‚¨å¯ä»¥ç¨åæ‰‹åŠ¨é…ç½®è¿œç¨‹æœåŠ¡å™¨"
        log_info "IX ç«¯ ens20 ç½‘å…³åº”è®¾ç½®ä¸º: $LOCAL_ENS20_IP"
        log_info "IX ç«¯ DNS åº”è®¾ç½®ä¸º: 1.1.1.1, 8.8.8.8"
    fi
}

###########################################
# å•ç‹¬å‘½ä»¤å¤„ç†å‡½æ•°
###########################################

handle_add_ip() {
    check_root
    local ip="$1"
    
    if [ -z "$ip" ]; then
        log_error "è¯·æŒ‡å®š IP åœ°å€"
        echo "ç”¨æ³•: $0 add <IPåœ°å€>"
        exit 1
    fi
    
    check_interface "$INTERNAL_IF"
    check_interface "$EXTERNAL_IF"
    
    add_allowed_ip "$ip"
    save_iptables
}

handle_del_ip() {
    check_root
    local ip="$1"
    
    if [ -z "$ip" ]; then
        log_error "è¯·æŒ‡å®š IP åœ°å€"
        echo "ç”¨æ³•: $0 del <IPåœ°å€>"
        exit 1
    fi
    
    check_interface "$INTERNAL_IF"
    check_interface "$EXTERNAL_IF"
    
    if iptables -C FORWARD -s "$ip" -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j ACCEPT 2>/dev/null; then
        iptables -D FORWARD -s "$ip" -i "$INTERNAL_IF" -o "$EXTERNAL_IF" -j ACCEPT
        log_info "âœ… å·²ä»å…è®¸åˆ—è¡¨åˆ é™¤ $ip"
        save_iptables
    else
        log_warn "IP $ip ä¸åœ¨å…è®¸åˆ—è¡¨ä¸­"
    fi
}

handle_list() {
    check_interface "$INTERNAL_IF"
    check_interface "$EXTERNAL_IF"
    
    print_header "å…è®¸è½¬å‘çš„ IP åˆ—è¡¨"
    
    INTERNAL_NETWORK=$(get_internal_network)
    EXTERNAL_IP=$(get_external_ip)
    LOCAL_ENS20_IP=$(get_internal_ip)
    
    echo -e "${BLUE}æœ¬æœºé…ç½®:${NC}"
    echo -e "  â€¢ å†…ç½‘æ¥å£: $INTERNAL_IF ($LOCAL_ENS20_IP)"
    echo -e "  â€¢ å¤–ç½‘æ¥å£: $EXTERNAL_IF ($EXTERNAL_IP)"
    echo -e "  â€¢ ç½‘æ®µ: $INTERNAL_NETWORK"
    echo ""
    
    local rules=$(iptables -L FORWARD -n -v --line-numbers | grep "$EXTERNAL_IF" | grep ACCEPT | grep -v "state RELATED,ESTABLISHED")
    
    if [ -z "$rules" ]; then
        log_warn "å½“å‰æ²¡æœ‰é…ç½®å…è®¸è½¬å‘çš„ IP"
    else
        echo -e "${GREEN}åºå·  æ•°æ®åŒ…  å­—èŠ‚æ•°    æºåœ°å€${NC}"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "$rules" | awk '{printf "%-6s%-8s%-10s%s\n", $1, $2, $3, $8}'
    fi
    
    echo ""
}

show_help() {
    cat << EOF
${GREEN}SNAT + ç­–ç•¥è·¯ç”± ä¸€ä½“åŒ–é…ç½®è„šæœ¬ (å¸¦æŒä¹…åŒ– + DNS + SSHè¯Šæ–­)${NC}

${YELLOW}ç”¨æ³•:${NC}
    $0                    # è¿è¡Œäº¤äº’å¼é…ç½®å‘å¯¼
    $0 <command> [args]   # æ‰§è¡Œå•ç‹¬å‘½ä»¤

${YELLOW}å¯ç”¨å‘½ä»¤:${NC}
    ${BLUE}setup${NC}               è¿è¡Œå®Œæ•´é…ç½®å‘å¯¼ï¼ˆæ¨èé¦–æ¬¡ä½¿ç”¨ï¼‰
    ${BLUE}add${NC} <IP>           æ·»åŠ å…è®¸è½¬å‘çš„ IP åœ°å€
    ${BLUE}del${NC} <IP>           åˆ é™¤å…è®¸è½¬å‘çš„ IP åœ°å€
    ${BLUE}list${NC}                åˆ—å‡ºæ‰€æœ‰å…è®¸è½¬å‘çš„ IP
    ${BLUE}clean${NC}               æ¸…ç©ºç­–ç•¥è·¯ç”±é…ç½®
    ${BLUE}test-ssh${NC} <IP>      æµ‹è¯• SSH è¿æ¥ï¼ˆè¯Šæ–­æ¨¡å¼ï¼‰
    ${BLUE}help${NC}                æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯

${YELLOW}é…ç½®å‘å¯¼åŒ…å«:${NC}
    1. è¾“å…¥ IX æœåŠ¡å™¨ IP å’Œå¯†ç ï¼ˆå¸¦ SSH è¯Šæ–­ï¼‰
    2. è‡ªåŠ¨å°† IX IP æ·»åŠ åˆ° SNAT å…è®¸åˆ—è¡¨
    3. å¯é€‰æ·»åŠ å…¶ä»–å…è®¸è½¬å‘çš„ IP
    4. è‡ªåŠ¨é…ç½®æœ¬åœ° SNAT
    5. è‡ªåŠ¨é…ç½®è¿œç¨‹ç­–ç•¥è·¯ç”±
    6. IX ç«¯ ens20 ç½‘å…³è‡ªåŠ¨è®¾ç½®ä¸ºæœ¬æœº ens20 IP
    7. IX ç«¯ DNS è®¾ç½®ä¸º 1.1.1.1 å’Œ 8.8.8.8
    8. æ‰€æœ‰é…ç½®è‡ªåŠ¨æŒä¹…åŒ–ï¼ˆé‡å¯åè‡ªåŠ¨æ¢å¤ï¼‰

${YELLOW}SSH è¯Šæ–­åŠŸèƒ½:${NC}
    â€¢ 6 æ­¥å®Œæ•´è¯Šæ–­æµç¨‹
    â€¢ è¯¦ç»†é”™è¯¯åˆ†æå’Œè§£å†³å»ºè®®
    â€¢ æ”¯æŒæœ€å¤š 3 æ¬¡å¯†ç é‡è¯•
    â€¢ ç‹¬ç«‹æµ‹è¯•å‘½ä»¤: $0 test-ssh <IP>

${YELLOW}ç¤ºä¾‹:${NC}
    # é¦–æ¬¡ä½¿ç”¨ - è¿è¡Œå®Œæ•´é…ç½®å‘å¯¼
    $0
    
    # æ·»åŠ æ›´å¤šå…è®¸çš„ IP
    $0 add 192.168.1.105
    
    # æŸ¥çœ‹å…è®¸åˆ—è¡¨
    $0 list
    
    # æ¸…ç©ºç­–ç•¥è·¯ç”±
    $0 clean
    
    # æµ‹è¯• SSH è¿æ¥
    $0 test-ssh 192.168.1.100

${YELLOW}å‰ç½®è¦æ±‚:${NC}
    â€¢ å¿…é¡»ä½¿ç”¨ root æƒé™è¿è¡Œ
    â€¢ éœ€è¦å®‰è£… sshpass: apt install sshpass
EOF
}

###########################################
# ä¸»å‡½æ•°
###########################################

main() {
    case "${1:-setup}" in
        setup|init|config|configure)
            interactive_setup
            ;;
        add)
            handle_add_ip "$2"
            ;;
        del|delete|remove)
            handle_del_ip "$2"
            ;;
        list|ls|show)
            handle_list
            ;;
        clean|clear|reset)
            clean_policy_routing
            ;;
        test-ssh)
            if [ -z "$2" ]; then
                echo "ç”¨æ³•: $0 test-ssh <IPåœ°å€> [ç«¯å£] [ç”¨æˆ·å]"
                exit 1
            fi
            read -s -p "è¯·è¾“å…¥ SSH å¯†ç : " password
            echo ""
            test_ssh_connection "$2" "$password" "${3:-22}" "${4:-root}"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            if [ -z "$1" ]; then
                interactive_setup
            else
                log_error "æœªçŸ¥å‘½ä»¤: $1"
                echo ""
                show_help
                exit 1
            fi
            ;;
    esac
}

# æ‰§è¡Œä¸»å‡½æ•°
main "$@"
